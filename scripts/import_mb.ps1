# Script d'import MusicBrainz officiel pour Windows PowerShell (via Docker)
# Usage: .\scripts\import_mb.ps1

param(
    [string]$DB_HOST = "127.0.0.1",
    [int]$DB_PORT = 5432,
    [string]$DB_NAME = "musicbrainz",
    [string]$DB_USER = "musicbrainz",
    [string]$DUMPS_DIR = "E:\mbdump",
    [string]$CONTAINER_NAME = "musicbrainz-postgres"
)

Write-Host "üöÄ D√©but de l'import MusicBrainz officiel via Docker..." -ForegroundColor Green

# V√©rifier que le conteneur est en cours d'ex√©cution
Write-Host "üê≥ V√©rification du conteneur $CONTAINER_NAME..." -ForegroundColor Yellow
try {
    $containerStatus = docker ps --filter "name=$CONTAINER_NAME" --format "{{.Status}}"
    if ([string]::IsNullOrEmpty($containerStatus)) {
        Write-Host "‚ùå Le conteneur $CONTAINER_NAME n'est pas en cours d'ex√©cution." -ForegroundColor Red
        Write-Host "üí° D√©marrez d'abord le conteneur avec: docker-compose up -d" -ForegroundColor Cyan
        exit 1
    }
    Write-Host "‚úÖ Conteneur $CONTAINER_NAME trouv√©: $containerStatus" -ForegroundColor Green
} catch {
    Write-Host "‚ùå Erreur lors de la v√©rification du conteneur Docker." -ForegroundColor Red
    Write-Host "üí° V√©rifiez que Docker Desktop est d√©marr√©." -ForegroundColor Cyan
    exit 1
}

# V√©rifier que PostgreSQL dans le conteneur est accessible
Write-Host "üì° V√©rification de la connexion PostgreSQL dans le conteneur..." -ForegroundColor Yellow
try {
    $result = docker exec $CONTAINER_NAME psql -U $DB_USER -d $DB_NAME -c "SELECT 1;" 2>$null
    if ($LASTEXITCODE -ne 0) {
        throw "Connexion √©chou√©e"
    }
    Write-Host "‚úÖ PostgreSQL accessible dans le conteneur" -ForegroundColor Green
} catch {
    Write-Host "‚ùå PostgreSQL n'est pas accessible dans le conteneur." -ForegroundColor Red
    Write-Host "üí° Attendez que PostgreSQL soit compl√®tement d√©marr√© dans le conteneur." -ForegroundColor Cyan
    exit 1
}

# V√©rifier la pr√©sence du r√©pertoire DUMPS_DIR
Write-Host "üìÅ V√©rification du r√©pertoire $DUMPS_DIR..." -ForegroundColor Yellow
if (-not (Test-Path $DUMPS_DIR)) {
    Write-Host "‚ùå R√©pertoire $DUMPS_DIR introuvable" -ForegroundColor Red
    Write-Host "üí° V√©rifiez le chemin vers vos fichiers MusicBrainz extraits" -ForegroundColor Cyan
    exit 1
}

# V√©rifier que le conteneur est d√©marr√© avec le bon montage
Write-Host "üîó V√©rification du montage des volumes..." -ForegroundColor Yellow
try {
    $mountInfo = docker inspect $CONTAINER_NAME --format "{{json .Mounts}}" | ConvertFrom-Json
    $dumpsMountFound = $false
    $correctMount = $false
    
    foreach ($mount in $mountInfo) {
        if ($mount.Destination -eq "/dumps") {
            $dumpsMountFound = $true
            Write-Host "‚úÖ Volume mont√©: $($mount.Source) -> /dumps" -ForegroundColor Green
            
            # V√©rifier si c'est le bon r√©pertoire mont√© (compatible Docker Desktop Windows)
            $isCorrectMount = ($mount.Source -eq $DUMPS_DIR) -or 
                             ($mount.Source -eq "/run/desktop/mnt/host/e/mbdump" -and $DUMPS_DIR -eq "E:\mbdump")
            
            if ($isCorrectMount) {
                $correctMount = $true
                Write-Host "‚úÖ Le bon r√©pertoire est mont√© ($DUMPS_DIR -> $($mount.Source))" -ForegroundColor Green
            } else {
                Write-Host "‚ö†Ô∏è  Attention: Vous avez mont√© [$($mount.Source)] mais vous voulez importer depuis [$DUMPS_DIR]" -ForegroundColor Yellow
                Write-Host "üí° Solutions possibles:" -ForegroundColor Cyan
                Write-Host "   1. Copiez vos fichiers E:\mbdump vers $($mount.Source)" -ForegroundColor Cyan
                Write-Host "   2. Ou ajustez docker-compose.yml pour monter $DUMPS_DIR vers /dumps" -ForegroundColor Cyan
            }
            break
        }
    }
    
    if (-not $dumpsMountFound) {
        Write-Host "‚ùå Volume /dumps non trouv√© dans le conteneur" -ForegroundColor Red
        Write-Host "üí° D√©marrez le conteneur avec docker-compose up -d (avec un volume mont√© vers /dumps)" -ForegroundColor Cyan
        exit 1
    }
    
    # Avertissement si le montage n'est pas correct
    if (-not $correctMount) {
        Write-Host "" 
        Write-Host "‚ö†Ô∏è  IMPORTANT: Le conteneur doit pouvoir acc√©der aux fichiers MusicBrainz via /dumps" -ForegroundColor Yellow
        Write-Host "üõ†Ô∏è  Solutions:" -ForegroundColor Cyan
        Write-Host "   1. Copiez E:\mbdump\* vers le r√©pertoire local mont√© par Docker" -ForegroundColor Cyan
        Write-Host "   2. Ou modifiez docker-compose.yml:" -ForegroundColor Cyan
        Write-Host "      volumes:" -ForegroundColor Cyan  
        Write-Host "        - E:\mbdump:/dumps:ro" -ForegroundColor Cyan
        Write-Host ""
        
        $response = Read-Host "Continuer quand m√™me ? (y/N)"
        if ($response -ne "y" -and $response -ne "Y") {
            Write-Host "üõë Arr√™t du script" -ForegroundColor Red
            exit 1
        }
    }
} catch {
    Write-Host "‚ö†Ô∏è  Impossible de v√©rifier les montages, continuation..." -ForegroundColor Yellow    
    Write-Host "üí° Assurez-vous que le conteneur peut acc√©der aux fichiers MusicBrainz via /dumps" -ForegroundColor Cyan
}

# V√©rifier SCHEMA_SEQUENCE depuis le conteneur
Write-Host "üîç V√©rification de SCHEMA_SEQUENCE..." -ForegroundColor Yellow
try {
    # Lire replication_control depuis le conteneur
    $replicationControlContent = docker exec $CONTAINER_NAME cat /dumps/replication_control 2>&1
    if ($LASTEXITCODE -eq 0) {
        # Extraire le deuxi√®me champ (SCHEMA_SEQUENCE)
        $schemaVersion = ($replicationControlContent -split '\t')[1]
        Write-Host "üìã Version du sch√©ma d√©tect√©e: $schemaVersion" -ForegroundColor Green
        
        if ($schemaVersion -ne "30") {
            Write-Host "‚ùå Version de sch√©ma incompatible: $schemaVersion (attendu: 30)" -ForegroundColor Red
            Write-Host "üí° Ce script est con√ßu pour MusicBrainz v30 uniquement" -ForegroundColor Cyan
            exit 1
        }
        Write-Host "‚úÖ Version de sch√©ma compatible: v30" -ForegroundColor Green
    } else {
        Write-Host "‚ùå Fichier replication_control introuvable dans /dumps du conteneur" -ForegroundColor Red
        Write-Host "üí° V√©rifiez que vous avez extrait le bon dump MusicBrainz" -ForegroundColor Cyan
        exit 1
    }
} catch {
    Write-Host "‚ùå Erreur lors de la lecture de replication_control: $($_.Exception.Message)" -ForegroundColor Red
    exit 1
}

# Lister les fichiers de donn√©es depuis le conteneur (ignorer les fichiers sp√©ciaux)
Write-Host "üìã Analyse des fichiers de donn√©es..." -ForegroundColor Yellow
$excludePatterns = @("README", "*_SEQUENCE", "COPYING", "*.md", "*.txt", "*.log", "replication_control")
$containerFileList = docker exec $CONTAINER_NAME ls /dumps 2>&1
if ($LASTEXITCODE -ne 0) {
    Write-Host "‚ùå Impossible de lister les fichiers dans /dumps du conteneur" -ForegroundColor Red
    exit 1
}

$allFiles = $containerFileList | Where-Object { 
    $fileName = $_.Trim()
    if ([string]::IsNullOrEmpty($fileName)) { return $false }
    
    $shouldExclude = $false
    foreach ($pattern in $excludePatterns) {
        if ($fileName -like $pattern) {
            $shouldExclude = $true
            break
        }
    }
    -not $shouldExclude
} | ForEach-Object { $_.Trim() }

# Trier les fichiers par ordre de d√©pendance (tables de r√©f√©rence en premier)
$referenceTables = $allFiles | Where-Object { 
    $_ -like "*_type" -or $_ -like "*_alias_type" -or $_ -like "*_format" -or $_ -like "*_status" -or $_ -like "*_packaging" -or $_ -like "*_ordering_type" -or $_ -like "*_primary_type" -or $_ -like "*_secondary_type" -or $_ -like "*_creditable_attribute_type" -or $_ -like "*_text_attribute_type" -or $_ -like "*_attribute_type" -or $_ -like "*_allowed_value" -or $_ -like "*_allowed_format" -or $_ -like "*_allowed_value_allowed_format" -or $_ -like "*_attribute_type_allowed_value" -or $_ -like "*_attribute_type_allowed_format" -or $_ -like "*_attribute_type_allowed_value_allowed_format" -or $_ -like "*_attribute_type_allowed_value_allowed_format" -or
    $_ -eq "gender" -or $_ -eq "script" -or $_ -eq "language" -or $_ -eq "orderable_link_type" -or $_ -eq "link_text_attribute_type" -or $_ -eq "link_creditable_attribute_type"
}

# Tables principales (sans d√©pendances complexes) - IMPORTANT: recording et release doivent venir avant medium/track/isrc/iswc
$mainTables = $allFiles | Where-Object { 
    $_ -eq "recording" -or $_ -eq "release" -or $_ -eq "area" -or $_ -eq "artist" -or $_ -eq "work" -or $_ -eq "label" -or $_ -eq "place" -or $_ -eq "event" -or $_ -eq "series" -or $_ -eq "genre" -or $_ -eq "instrument" -or $_ -eq "link" -or $_ -eq "url" -or $_ -eq "tag" -or $_ -eq "annotation" -or $_ -eq "editor" -or $_ -eq "edit" -or $_ -eq "vote" -or $_ -eq "cdtoc" -or $_ -eq "iso_3166_1" -or $_ -eq "iso_3166_2" -or $_ -eq "iso_3166_3" -or $_ -eq "country_area"
}

$otherTables = $allFiles | Where-Object { 
    $_ -notlike "*_type" -and $_ -notlike "*_alias_type" -and $_ -notlike "*_format" -and $_ -notlike "*_status" -and $_ -notlike "*_packaging" -and $_ -notlike "*_ordering_type" -and $_ -notlike "*_primary_type" -and $_ -notlike "*_secondary_type" -and $_ -notlike "*_creditable_attribute_type" -and $_ -notlike "*_text_attribute_type" -and $_ -notlike "*_attribute_type" -and $_ -notlike "*_allowed_value" -and $_ -notlike "*_allowed_format" -and $_ -notlike "*_allowed_value_allowed_format" -and $_ -notlike "*_attribute_type_allowed_value" -and $_ -notlike "*_attribute_type_allowed_format" -and $_ -notlike "*_attribute_type_allowed_value_allowed_format" -and $_ -notlike "*_attribute_type_allowed_value_allowed_format" -and
    $_ -ne "gender" -and $_ -ne "script" -and $_ -ne "language" -and $_ -ne "orderable_link_type" -and $_ -ne "link_text_attribute_type" -and $_ -ne "link_creditable_attribute_type" -and
    $_ -ne "area" -and $_ -ne "artist" -and $_ -ne "recording" -and $_ -ne "release" -and $_ -ne "work" -and $_ -ne "label" -and $_ -ne "place" -and $_ -ne "event" -and $_ -ne "series" -and $_ -ne "genre" -and $_ -ne "instrument" -and $_ -ne "medium" -and $_ -ne "track" -and $_ -ne "link" -and $_ -ne "url" -and $_ -ne "tag" -and $_ -ne "annotation" -and $_ -ne "editor" -and $_ -ne "edit" -and $_ -ne "vote" -and $_ -ne "cdtoc" -and $_ -ne "isrc" -and $_ -ne "iswc" -and $_ -ne "iso_3166_1" -and $_ -ne "iso_3166_2" -and $_ -ne "iso_3166_3" -and $_ -ne "country_area"
}

# Ordre d'import : tables de r√©f√©rence d'abord, puis tables principales, puis autres tables
$dataFiles = ($referenceTables + $mainTables + $otherTables) | ForEach-Object { [PSCustomObject]@{ Name = $_ } }

if ($dataFiles.Count -eq 0) {
    Write-Host "‚ùå Aucun fichier de donn√©es trouv√© dans /dumps du conteneur" -ForegroundColor Red
    Write-Host "üí° V√©rifiez que le dump MusicBrainz est correctement extrait" -ForegroundColor Cyan
    exit 1
}

Write-Host "üì¶ Trouv√© $($dataFiles.Count) fichiers de donn√©es √† importer" -ForegroundColor Green
Write-Host "üìã Ordre d'import: $($referenceTables.Count) tables de r√©f√©rence, puis $($mainTables.Count) tables principales, puis $($otherTables.Count) autres tables" -ForegroundColor Cyan

# V√©rifier si on doit reprendre un import partiel
Write-Host "üîç V√©rification de l'√©tat actuel des donn√©es..." -ForegroundColor Yellow
$importedTables = @()
$failedTable = ""

try {
    # V√©rifier si 'recording' existe (table pr√©c√©dente de 'isrc')
    $recordingCount = docker exec $CONTAINER_NAME psql -U $DB_USER -d $DB_NAME -t -c "SELECT COUNT(*) FROM musicbrainz.recording;" 2>&1
    
    if ($LASTEXITCODE -eq 0 -and $recordingCount.Trim() -as [int] -gt 0) {
        Write-Host "‚úÖ Table 'recording' d√©j√† import√©e avec succ√®s ($($recordingCount.Trim()) lignes)" -ForegroundColor Green
        Write-Host "üöÄ Reprise depuis la table 'isrc' (qui a √©chou√©)..." -ForegroundColor Cyan
        
        # Trouver l'index de 'isrc' et reprendre depuis l√†
        $isrcIndex = -1
        for ($i = 0; $i -lt $dataFiles.Count; $i++) {
            if ($dataFiles[$i].Name -eq "isrc") {
                $isrcIndex = $i
                break
            }
        }
        
        if ($isrcIndex -gt -1) {
            Write-Host "üìç Reprise depuis l'index $($isrcIndex + 1) ('isrc' et suivantes)" -ForegroundColor Cyan
            Write-Host "üßπ Nettoyage des tables probl√©matiques entre 'recording' et 'isrc'..." -ForegroundColor Yellow
            
            # Supprimer les tables qui pourraient causer des conflits
            $problematicTables = @("isrc", "iswc")
            foreach ($table in $problematicTables) {
                try {
                    $result = docker exec $CONTAINER_NAME psql -U $DB_USER -d $DB_NAME -c "DELETE FROM musicbrainz.$table;" 2>&1
                    if ($LASTEXITCODE -eq 0) {
                        Write-Host "üóëÔ∏è Table $table nettoy√©e" -ForegroundColor Green
                    }
                } catch {
                    Write-Host "‚ö†Ô∏è Impossible de nettoyer $table" -ForegroundColor Yellow
                }
            }
            
            $dataFiles = $dataFiles[$isrcIndex..($dataFiles.Count - 1)]
        }
    } else {
        Write-Host "üí° Table 'recording' non trouv√©e ou vide - si l'ordre est correct, 'recording' doit √™tre import√©e avant 'isrc'" -ForegroundColor Yellow
    }
} catch {
    Write-Host "‚ö†Ô∏è Impossible de v√©rifier l'√©tat des tables" -ForegroundColor Yellow
}

# Les tables avec dataFiles mis √† jour sont d√©j√† filtr√©es si n√©cessaire

# Importer chaque fichier de donn√©es avec \copy
Write-Host "üì• Import des donn√©es MusicBrainz avec \\copy (cela peut prendre plusieurs heures)..." -ForegroundColor Yellow
Write-Host "‚è≥ Cette √©tape peut prendre plusieurs heures selon la taille des donn√©es..." -ForegroundColor Cyan

$totalFiles = $dataFiles.Count
$successCount = 0
$failedFiles = @()

for ($i = 0; $i -lt $totalFiles; $i++) {
    $file = $dataFiles[$i]
    $fileNumber = $i + 1
    $tableName = $file.Name
    
    Write-Host "üìÑ [$fileNumber/$totalFiles] Import en cours: $tableName..." -ForegroundColor Cyan
    Write-Host "   üê≥ Chemin conteneur: /dumps/$tableName" -ForegroundColor DarkGray
    
    try {
        # Utiliser \copy pour importer les donn√©es
        $copyCommand = "\copy ${tableName} FROM '/dumps/${tableName}' WITH (FORMAT text, DELIMITER E'\t', NULL '\N');"
        $result = docker exec $CONTAINER_NAME psql -U $DB_USER -d $DB_NAME -c $copyCommand 2>&1
        if ($LASTEXITCODE -eq 0) {
            $successCount++
            Write-Host "‚úÖ [$fileNumber/$totalFiles] $tableName import√© avec succ√®s" -ForegroundColor Green
        } else {
            $failedFiles += $tableName
            Write-Host "‚ùå [$fileNumber/$totalFiles] Erreur lors de l'import de $tableName" -ForegroundColor Red
            Write-Host "   üìù Message d'erreur: $result" -ForegroundColor Red
            Write-Host "   üõë Arr√™t de l'importation..." -ForegroundColor Red
            exit 1
        }
    } catch {
        $failedFiles += $tableName
        Write-Host "‚ùå [$fileNumber/$totalFiles] Exception lors de l'import de $tableName : $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "   üõë Arr√™t de l'importation..." -ForegroundColor Red
        exit 1
    }
}

Write-Host "üìä R√©sum√© de l'importation:" -ForegroundColor Yellow
Write-Host "   ‚úÖ Fichiers import√©s avec succ√®s: $successCount / $totalFiles" -ForegroundColor Green
if ($failedFiles.Count -gt 0) {
    Write-Host "   ‚ùå Fichiers √©chou√©s: $($failedFiles.Count)" -ForegroundColor Red
    Write-Host "   üìã Fichiers probl√©matiques: $($failedFiles -join ', ')" -ForegroundColor Red
    exit 1
}

# Les contraintes sont d√©j√† actives apr√®s TRUNCATE CASCADE
Write-Host "‚úÖ Contraintes FK actives apr√®s nettoyage" -ForegroundColor Green

# Cr√©er les extensions n√©cessaires
Write-Host "üîß Installation des extensions PostgreSQL..." -ForegroundColor Yellow
try {
    docker exec $CONTAINER_NAME psql -U $DB_USER -d $DB_NAME -c @"
CREATE EXTENSION IF NOT EXISTS cube;
CREATE EXTENSION IF NOT EXISTS earthdistance;
"@
    if ($LASTEXITCODE -eq 0) {
        Write-Host "‚úÖ Extensions install√©es avec succ√®s" -ForegroundColor Green
    } else {
        Write-Host "‚ö†Ô∏è  Avertissement: Erreur lors de l'installation des extensions" -ForegroundColor Yellow
    }
} catch {
    Write-Host "‚ö†Ô∏è  Avertissement: Exception lors de l'installation des extensions" -ForegroundColor Yellow
}

Write-Host "‚úÖ Import MusicBrainz officiel v30 termin√© avec succ√®s!" -ForegroundColor Green
Write-Host "üîç Vous pouvez maintenant appliquer les index avec: .\scripts\apply_mb_indexes.ps1" -ForegroundColor Cyan
Write-Host "üìä Base de donn√©es accessible via le conteneur: $CONTAINER_NAME" -ForegroundColor Cyan